/**
 * JSON Exorcist - Converts package.json to living package.ts
 * "Truth is the signal, JSON is the noise"
 */

import * as fs from 'fs';
import * as path from 'path';
import * as ts from 'typescript';
import { createHash } from 'crypto';
import { createLivingPackage, SemanticSignalStore } from '../core/package-signal-store';

interface ExorcismOptions {
	preserveScripts?: boolean;
	dedupeGlobally?: boolean;
	burnTheCruft?: boolean;
	verbose?: boolean;
}

interface ExorcismReport {
	originalLines: number;
	newLines: number;
	noiseRemoved: number;
	duplicatesFound: number;
	savingsBytes: number;
}

export class JSONExorcist {
	private report: ExorcismReport = {
		originalLines: 0,
		newLines: 0,
		noiseRemoved: 0,
		duplicatesFound: 0,
		savingsBytes: 0
	};

	constructor(private options: ExorcismOptions = {}) {}

	/**
	 * Main exorcism ritual
	 */
	async exorcise(packageJsonPath: string): Promise<string> {
		console.log('ü™û Beginning JSON Exorcism...\n');

		// Read the cursed JSON
		const jsonContent = fs.readFileSync(packageJsonPath, 'utf8');
		const packageJson = JSON.parse(jsonContent);
		this.report.originalLines = jsonContent.split('\n').length;

		// Extract the truth from the noise
		const truth = this.extractTruth(packageJson);
		
		// Generate living package.ts
		const packageTs = this.generatePackageTs(truth);
		this.report.newLines = packageTs.split('\n').length;
		this.report.noiseRemoved = this.report.originalLines - this.report.newLines;

		// Write the cleansed version
		const outputPath = packageJsonPath.replace('.json', '.ts');
		fs.writeFileSync(outputPath, packageTs);

		// Report the exorcism results
		this.printReport();

		return outputPath;
	}

	/**
	 * Extract only meaningful content from package.json
	 */
	private extractTruth(pkg: any): any {
		const truth: any = {
			name: pkg.name,
			// Version will be auto-computed
			exports: [],
			imports: [],
			scripts: {}
		};

		// Preserve useful scripts if requested
		if (this.options.preserveScripts && pkg.scripts) {
			// Only keep meaningful scripts, not npm lifecycle noise
			const meaningfulScripts = ['build', 'test', 'dev', 'start', 'lint'];
			for (const script of meaningfulScripts) {
				if (pkg.scripts[script]) {
					truth.scripts[script] = pkg.scripts[script];
				}
			}
		}

		// Extract real dependencies from code, not declared ones
		if (pkg.main) {
			truth.main = pkg.main;
		}

		// Burn the cruft if requested
		if (this.options.burnTheCruft) {
			// These fields are pure noise
			const cruft = [
				'description', 'keywords', 'author', 'license',
				'homepage', 'repository', 'bugs', 'funding',
				'engines', 'os', 'cpu', 'publishConfig'
			];
			
			cruft.forEach(field => {
				if (pkg[field]) {
					console.log(`üî• Burning cruft: ${field}`);
				}
			});
		}

		return truth;
	}

	/**
	 * Generate clean package.ts from extracted truth
	 */
	private generatePackageTs(truth: any): string {
		const lines: string[] = [
			`/**`,
			` * Living Package Manifest`,
			` * Generated by JSON Exorcist`,
			` * Truth extracted from ${this.report.originalLines} lines of JSON noise`,
			` */`,
			``,
			`import { signal, computed } from '@angular/core';`,
			`import { SemanticSignalStore } from '@fnpm/core';`,
			``,
			`// Initialize semantic store`,
			`const store = new SemanticSignalStore('${truth.name}');`,
			``,
			`// Export living package`,
			`export const pkg = signal({`,
			`  name: '${truth.name}',`,
			`  `,
			`  // Version auto-computed from content hash`,
			`  version: computed(() => {`,
			`    const fingerprints = Array.from(store.getAllFingerprints());`,
			`    return store.computeSemanticVersion(fingerprints);`,
			`  }),`,
			`  `,
			`  // Exports will be added as semantic units`,
			`  exports: new Map(),`,
			`  `,
			`  // Dependencies auto-detected from AST`,
			`  imports: computed(() => store.getSemanticDependencies()),`,
		];

		// Add preserved scripts if any
		if (Object.keys(truth.scripts).length > 0) {
			lines.push(`  `);
			lines.push(`  // Preserved useful scripts`);
			lines.push(`  scripts: {`);
			for (const [name, command] of Object.entries(truth.scripts)) {
				lines.push(`    ${name}: '${command}',`);
			}
			lines.push(`  },`);
		}

		lines.push(`  `);
		lines.push(`  // Semantic store for deduplication`);
		lines.push(`  store`);
		lines.push(`});`);
		lines.push(``);
		lines.push(`// Example: Add semantic unit`);
		lines.push(`// const myFunction = store.createUnit(\`);
		lines.push(`//   export function doSomething(x: number): number {`);
		lines.push(`//     return x * 2;`);
		lines.push(`//   }`);
		lines.push(`// \`, [`);
		lines.push(`//   () => doSomething(5) === 10`);
		lines.push(`// ], 'Doubles a number');`);
		lines.push(`// `);
		lines.push(`// pkg().exports.set('doSomething', myFunction);`);

		return lines.join('\n');
	}

	/**
	 * Scan node_modules for duplicates
	 */
	async scanForDuplicates(nodeModulesPath: string): Promise<void> {
		console.log('üîç Scanning for duplicate functions...\n');

		const fingerprints = new Map<string, string[]>(); // fingerprint -> [package names]
		let totalSize = 0;
		let uniqueSize = 0;

		// Recursive scan
		const scan = (dir: string, packageName: string) => {
			const files = fs.readdirSync(dir);
			
			for (const file of files) {
				const filePath = path.join(dir, file);
				const stat = fs.statSync(filePath);
				
				if (stat.isDirectory() && file !== 'node_modules') {
					scan(filePath, packageName);
				} else if (file.endsWith('.js') || file.endsWith('.ts')) {
					// Read and fingerprint
					const content = fs.readFileSync(filePath, 'utf8');
					totalSize += content.length;
					
					const fingerprint = this.generateCodeFingerprint(content);
					
					if (!fingerprints.has(fingerprint)) {
						fingerprints.set(fingerprint, []);
						uniqueSize += content.length;
					}
					fingerprints.get(fingerprint)!.push(`${packageName}/${file}`);
				}
			}
		};

		// Scan each package
		const packages = fs.readdirSync(nodeModulesPath);
		for (const pkg of packages) {
			if (pkg.startsWith('.')) continue;
			const pkgPath = path.join(nodeModulesPath, pkg);
			if (fs.statSync(pkgPath).isDirectory()) {
				scan(pkgPath, pkg);
			}
		}

		// Report duplicates
		let duplicateCount = 0;
		for (const [fingerprint, locations] of fingerprints) {
			if (locations.length > 1) {
				duplicateCount++;
				if (this.options.verbose) {
					console.log(`Duplicate found in: ${locations.join(', ')}`);
				}
			}
		}

		this.report.duplicatesFound = duplicateCount;
		this.report.savingsBytes = totalSize - uniqueSize;

		console.log(`\nüìä Duplication Report:`);
		console.log(`   Total functions: ${fingerprints.size}`);
		console.log(`   Duplicates: ${duplicateCount}`);
		console.log(`   Current size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);
		console.log(`   After dedup: ${(uniqueSize / 1024 / 1024).toFixed(2)} MB`);
		console.log(`   Savings: ${(this.report.savingsBytes / 1024 / 1024).toFixed(2)} MB (${((1 - uniqueSize/totalSize) * 100).toFixed(1)}%)\n`);
	}

	/**
	 * Generate fingerprint for code
	 */
	private generateCodeFingerprint(code: string): string {
		// Simple version - in production would use proper AST parsing
		const normalized = code
			.replace(/\/\*[\s\S]*?\*\//g, '') // Remove comments
			.replace(/\/\/.*/g, '')
			.replace(/\s+/g, ' ')
			.trim();
		
		const hash = createHash('sha256');
		hash.update(normalized);
		return hash.digest('hex').substring(0, 16);
	}

	/**
	 * Print exorcism report
	 */
	private printReport(): void {
		console.log('\n‚ú® Exorcism Complete!\n');
		console.log('üìä Results:');
		console.log(`   Original lines: ${this.report.originalLines}`);
		console.log(`   New lines: ${this.report.newLines}`);
		console.log(`   Noise removed: ${this.report.noiseRemoved} lines (${(this.report.noiseRemoved / this.report.originalLines * 100).toFixed(1)}%)`);
		console.log(`   Signal-to-noise improvement: ${(this.report.originalLines / this.report.newLines).toFixed(1)}x`);
		
		if (this.report.duplicatesFound > 0) {
			console.log(`   Duplicates found: ${this.report.duplicatesFound}`);
			console.log(`   Potential savings: ${(this.report.savingsBytes / 1024 / 1024).toFixed(2)} MB`);
		}

		console.log('\nüéâ Your package has been cleansed!');
		console.log('   JSON bureaucracy ‚Üí Semantic signals');
		console.log('   Static manifest ‚Üí Living package');
		console.log('   Fear-driven versions ‚Üí Content-based truth\n');
	}
}

// CLI Interface
if (require.main === module) {
	const args = process.argv.slice(2);
	
	if (args.length === 0) {
		console.log('Usage: ts-node json-exorcist.ts <package.json> [options]');
		console.log('Options:');
		console.log('  --preserve-scripts    Keep useful scripts');
		console.log('  --dedupe-globally    Connect to global SignalStore');
		console.log('  --burn-the-cruft     Remove all noise fields');
		console.log('  --scan <path>        Scan for duplicates');
		process.exit(1);
	}

	const exorcist = new JSONExorcist({
		preserveScripts: args.includes('--preserve-scripts'),
		dedupeGlobally: args.includes('--dedupe-globally'),
		burnTheCruft: args.includes('--burn-the-cruft'),
		verbose: args.includes('--verbose')
	});

	if (args.includes('--scan')) {
		const scanIndex = args.indexOf('--scan');
		const scanPath = args[scanIndex + 1] || './node_modules';
		exorcist.scanForDuplicates(scanPath);
	} else {
		exorcist.exorcise(args[0]);
	}
}

// Export for programmatic use
export { exorcise } from './exorcism-api';