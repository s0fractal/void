âŸ: Functor
ğŸ¯: category-functor-morphism
ğŸ§®: (F: A â†’ B) preserving structure
ğŸ’­: "Ğ¤ÑƒĞ½ĞºÑ‚Ğ¾Ñ€ ÑĞº Ğ·Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¸ Ğ¼Ñ–Ğ¶ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ñ–ÑĞ¼Ğ¸"

ğŸ§ :
  description: "Functors preserve categorical structure"
  signature: "(Category A, Category B) â†’ (A â†’ B)"
  pure: true
  idempotent: false

dependencies:
  - glyph://category-theory@foundation
  - glyph://morphism@base

types:
  Functor<A, B>:
    mapObject: "(obj: A) â†’ B"
    mapMorphism: "(f: Aâ‚ â†’ Aâ‚‚) â†’ (F(Aâ‚) â†’ F(Aâ‚‚))"
    laws:
      - identity: "F(id_A) = id_F(A)"
      - composition: "F(g âˆ˜ f) = F(g) âˆ˜ F(f)"

implementations:
  List:
    âŸ: ListFunctor
    ğŸ§®: |
      {
        map: (f) => (list) => list.map(f),
        preservesIdentity: true,
        preservesComposition: true
      }
    ğŸ¯: "List is a functor"
    
  Maybe:
    âŸ: MaybeFunctor
    ğŸ§®: |
      {
        map: (f) => (maybe) => 
          maybe.isNothing() ? Nothing() : Just(f(maybe.value)),
        preservesIdentity: true,
        preservesComposition: true
      }
    ğŸ¯: "Maybe/Option is a functor"
    
  Promise:
    âŸ: PromiseFunctor
    ğŸ§®: |
      {
        map: (f) => (promise) => promise.then(f),
        preservesIdentity: true,
        preservesComposition: true
      }
    ğŸ¯: "Promise is a functor"
    
  Signal:
    âŸ: SignalFunctor
    ğŸ§®: |
      {
        map: (f) => (signal) => computed(() => f(signal())),
        preservesIdentity: true,
        preservesComposition: true
      }
    ğŸ¯: "Signal is a functor (reactive)"

composition:
  compose:
    âŸ: composeFunctors
    ğŸ§©: [F, G]
    ğŸ§®: |
      {
        map: (f) => F.map(G.map(f)),
        preservesIdentity: F.preservesIdentity && G.preservesIdentity,
        preservesComposition: true
      }
    ğŸ¯: "F âˆ˜ G functor composition"

natural_transformations:
  listToMaybe:
    âŸ: headNT
    ğŸ§®: "(list) => list.length > 0 ? Just(list[0]) : Nothing()"
    ğŸ¯: "Natural transformation List â†’ Maybe"
    
  promiseToSignal:
    âŸ: promiseSignalNT
    ğŸ§®: |
      (promise) => {
        const sig = signal(null);
        promise.then(value => sig.set(value));
        return sig;
      }
    ğŸ¯: "Natural transformation Promise â†’ Signal"

laws_verification:
  identity_law: |
    const id = x => x;
    F.map(id)(container) === container
    
  composition_law: |
    const f = x => x + 1;
    const g = x => x * 2;
    F.map(x => g(f(x)))(container) === F.map(g)(F.map(f)(container))

usage:
  simple: |
    // List functor
    const numbers = [1, 2, 3];
    const doubled = ListFunctor.map(x => x * 2)(numbers);
    // [2, 4, 6]
    
  reactive: |
    // Signal functor for reactive programming
    const count = signal(0);
    const doubled = SignalFunctor.map(x => x * 2)(count);
    // doubled() === 0
    count.set(5);
    // doubled() === 10
    
  composed: |
    // Composed functors
    const ListOfMaybe = composeFunctors(ListFunctor, MaybeFunctor);
    const data = [Just(1), Nothing(), Just(3)];
    const result = ListOfMaybe.map(x => x + 1)(data);
    // [Just(2), Nothing(), Just(4)]

resonance:
  frequency: 432
  pattern: "structure-preserving-transformation"
  insight: "Functors are the morphisms between categories"