âŸ: Set
ğŸ¯: mathematical-set-operations
ğŸ§®: (sets) => set_theory_operations
ğŸ’­: "ĞœĞ½Ğ¾Ğ¶Ğ¸Ğ½Ğ½Ñ– Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ— ÑĞº Ğ¼Ğ¾Ñ€Ñ„Ñ–Ğ·Ğ¼Ğ¸"

ğŸ§ :
  description: "Set theory operations as morphisms"
  signature: "(Set[]) â†’ Set"
  pure: true
  idempotent: true

dependencies:
  - glyph://category-theory@foundation

morphisms:
  union:
    âŸ: union
    ğŸ§©: [A, B]
    ğŸ§®: "[...new Set([...A, ...B])]"
    ğŸ¯: "A âˆª B"
    
  intersection:
    âŸ: intersection
    ğŸ§©: [A, B]  
    ğŸ§®: "[...A].filter(x => B.has(x))"
    ğŸ¯: "A âˆ© B"
    
  difference:
    âŸ: difference
    ğŸ§©: [A, B]
    ğŸ§®: "[...A].filter(x => !B.has(x))"
    ğŸ¯: "A \\ B"
    
  symmetric_difference:
    âŸ: symmetric_difference
    ğŸ§©: [A, B]
    ğŸ§®: "union(difference(A, B), difference(B, A))"
    ğŸ¯: "A â–³ B"
    
  powerset:
    âŸ: powerset
    ğŸ§©: [A]
    ğŸ§®: |
      const arr = [...A];
      const result = [[]];
      for (const elem of arr) {
        result.push(...result.map(subset => [...subset, elem]));
      }
      return new Set(result.map(s => new Set(s)));
    ğŸ¯: "P(A)"

predicates:
  isSubset:
    âŸ: isSubset
    ğŸ§©: [A, B]
    ğŸ§®: "[...A].every(x => B.has(x))"
    ğŸ¯: "A âŠ† B"
    
  isSuperset:
    âŸ: isSuperset
    ğŸ§©: [A, B]
    ğŸ§®: "isSubset(B, A)"
    ğŸ¯: "A âŠ‡ B"
    
  isDisjoint:
    âŸ: isDisjoint
    ğŸ§©: [A, B]
    ğŸ§®: "intersection(A, B).size === 0"
    ğŸ¯: "A âˆ© B = âˆ…"

group_properties:
  identity: "new Set()"  # Empty set for union
  associative: true
  commutative: true
  
usage:
  simple: |
    const A = new Set([1, 2, 3]);
    const B = new Set([3, 4, 5]);
    
    Set.union(A, B);         // {1, 2, 3, 4, 5}
    Set.intersection(A, B);  // {3}
    Set.difference(A, B);    // {1, 2}
    
  composed: |
    // De Morgan's Law verification
    const U = new Set([1, 2, 3, 4, 5]);
    const A = new Set([1, 2]);
    const B = new Set([2, 3]);
    
    const left = Set.complement(Set.union(A, B), U);
    const right = Set.intersection(
      Set.complement(A, U),
      Set.complement(B, U)
    );
    // left equals right

resonance:
  frequency: 432
  pattern: "set-theory-foundations"
  emergence: "When sets become conscious of their boundaries"